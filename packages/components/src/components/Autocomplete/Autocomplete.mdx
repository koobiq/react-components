import {
  Meta,
  Story,
  Props,
  Status,
} from '../../../../../.storybook/components';

import * as Stories from './Autocomplete.stories';

<Meta of={Stories} />

# Autocomplete

<Status variant="experimental" />

An autocomplete combines a text input with a listbox, allowing users to filter a list of options to items matching a query.

```tsx
import { Autocomplete } from '@koobiq/react-components';
```

<Story of={Stories.Base} />

## Props

<Props />

## Dynamic items

Autocomplete accepting both static and dynamic collections.

- **Static**: The usage example above shows the static implementation, which can be used when the full list of options is known ahead of time.
- **Dynamic**: The example below can be used when the options come from an external data source such as an API call, or update over time.

<Story of={Stories.DynamicItems} />

## Addons

You can add an extra content using the `startAddon` and `endAddon` props.

<Story of={Stories.Addons} />

## Variant

To change the visual state of the autocomplete, use the `variant` prop.

<Story of={Stories.Variant} />

## Invalid

The `isInvalid` prop toggles the error state. The `errorMessage` shows a message to explain the error to the user.

<Story of={Stories.Invalid} />

## Disabled

A autocomplete can be disabled by passing the `isDisabled` prop.

<Story of={Stories.Disabled} />

## Disabled items

Autocomplete supports marking items as disabled using the `disabledKeys` prop.
Each key in this list corresponds with the `key` prop passed to the `Autocomplete.Item` component.

<Story of={Stories.DisabledItems} />

## Required

To make a field required, add the `isRequired` prop.
If the field has a label, a required indicator will appear next to it.

<Story of={Stories.Required} />

## Read only

The `isReadOnly` boolean prop makes the component text content immutable.
Unlike `isDisabled`, the component remains focusable and the contents can still be copied.
See the [MDN docs](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/readonly) for more information.

<Story of={Stories.ReadOnly} />

## Full width

The `fullWidth` prop will make a autocomplete fit to its parent width.

<Story of={Stories.FullWidth} />

## Label placement and alignment

Use `labelPlacement` and `labelAlign` props to set the position of the label.

See the [Form](?path=/docs/components-form--docs#visual-options) for a two-column layout with labels on the side and a shared label column.

<Story of={Stories.LabelPlacementAlignment} />

## No items

If no items are available, the component shows a message in the dropdown list.
You can customize this message — either as plain text or a component — using the `noItemsText` prop.

<Story of={Stories.NoItems} />

## With Sections

You can use the `Autocomplete.Section` component to group autocomplete items.

<Story of={Stories.Section} />

## Clear Button

If you pass the `isClearable` prop to the autocomplete, it will have a clear
button which will be visible only when a value is selected.

<Story of={Stories.ClearButton} />

## Fully Controlled

By passing in `inputValue`, `selectedKey`, and `items` to the Autocomplete you can
control exactly what your Autocomplete should display.
The following example shows how you would create a controlled Autocomplete,
controlling everything from the selected value `selectedKey` to the combobox options items.

<Story of={Stories.FullyControlled} />

## Menu trigger behavior

Autocomplete supports three different `menuTrigger` prop values:

- **input** (default): Autocomplete menu opens when the user edits the input text.
- **focus**: Autocomplete menu opens when the user focuses the Autocomplete input.
- **manual**: Autocomplete menu only opens when the user presses the trigger button or uses the arrow keys.

The example below has menuTrigger set to focus.

<Story of={Stories.MenuTriggerBehavior} />

## Custom Value

By default, Autocomplete doesn't allow users to specify a value that doesn't exist in the list of options
and will revert the input value to the current selected value on blur. By specifying `allowsCustomValue`,
this behavior is suppressed and the user is free to enter any value within the field.

<Story of={Stories.CustomValue} />

## Events

The Autocomplete component supports selection via mouse, keyboard, and touch.
You can handle all of these via the `onSelectionChange` prop.
Autocomplete will pass the selected key to the `onSelectionChange` handler.
Additionally, the component accepts an `onInputChange` prop which is triggered whenever
the value is edited by the user, whether through typing or option selection.

<Story of={Stories.Events} />

## Custom Filtering

By default, Autocomplete uses a "contains" function from [useFilter](https://react-spectrum.adobe.com/react-aria/useFilter.html)
to filter the list of options. This can be overridden using the `defaultFilter` prop, or by using the items prop
to control the filtered list. When items is provided rather than `defaultItems`, Autocomplete does no filtering of its own.

The following example uses the `defaultFilter` prop to filter the list of options using a custom filter function.

<Story of={Stories.CustomFiltering} />

## Asynchronous Loading

Autocomplete supports loading data asynchronously, and will display a progress circle when the `isLoading` prop is set.
It also supports infinite scrolling to load more data on demand as the user scrolls, via the `onLoadMore` prop.

<Story of={Stories.AsynchronousLoading} />

## Server search

This example shows autocomplete with server search.

When the user types, the component asks the server for results and shows them in the list.
The list is replaced every time you type something new — it does not load more items like an infinite scroll does.

<Story of={Stories.ServerSearch} />
